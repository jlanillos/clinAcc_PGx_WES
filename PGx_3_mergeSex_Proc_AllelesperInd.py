# This script merges restricted information (per individual gender, NGS panel and country location) with alleles retrieved in the previous script (PGx_2_mergedAlleles_CCP17_SSV6_together.py)
# It creates a dataframe which contains one row per individual (N=5,001) and coluns with all actionable genes filled with their PGx diplotype information whenever they are carriers
# The output file (haplotypes.csv) serves as input to retrieve some statistics, create some SuppTables with alleles per population
# The output file also serves to translate diplotype information final PGx phenotype information per individual

# Important note: In this script, some PGx alleles have undergone manual curation when required (redundant alleles, compound heterozygous cases...) : TPMT, SLCO1B1, G6PD, CYP2B6
import pandas as pd
import numpy as np
import re
GENDER = pd.read_csv('dictionary_gender.csv',sep='\t')
proc = pd.read_csv('dictionary_proc.csv',sep='\t')
df = proc.copy()
df['gender'] = df['sample'].map(dict(zip(list(GENDER['annonimousID']),list(GENDER['gender'])))) # F=Female;M=Male
panel = pd.read_csv('sample_panel_CCP17orSSV6.csv',sep='\t')
d = dict(zip(list(panel['sample'].astype(str)),list(panel['panel'])))
df['sample'] = df['sample'].astype(str)
df['panel'] = df['sample'].map(d)

# Read Alleles tables (This table has been previously generated by merging alleles from SSV6 and CCP17 panels)
alleles = pd.read_csv('Alleles.csv',sep='\t')
alleles = alleles.loc[(alleles['count_carrier_ids'].astype(str) != 'nan') & (alleles['Actionable allele'] == 'Yes')].copy() # Keep only actionable alleles
ref = pd.read_csv('Ref_table.csv',sep='\t')
actref = ref.loc[(ref['SNV_only'] == 'SNV')] # This round, analyze only alleles with SNVs. Indels are added below
actref['ID'] = actref['Gene Symbol'] + '_' + actref['allele'] + '_' + actref['Allele Clinical Functional Status (Required)'].astype(str)
alleles = alleles.loc[alleles['ID'].isin(list(actref['ID']))] # Keep alelles with SNVs only


genot = list(alleles['onlypositivevalues_carrier_gt'].astype(str)) # Convert to to list the column that containg carriers' genotypes
samples = list(alleles['onlypositivevalues_carrier_ids'].astype(str)) # Convert to to list the column that containg carriers' sample ids

alleles['aux'] = alleles['allele'].str.replace('_','-') #To avoid misspelling issues later with G6PD, which contains '_' symbol in their allele definitions
alleles['aux'] = alleles['aux'].str.replace(' ','') #To avoid misspelling issues later with G6PD, which contains ', ' symbol in their allele definitions
alleles['aux'] = alleles['aux'].str.replace(' ','') #To avoid misspelling issues later with G6PD, which contains ', ' symbol in their allele definitions
alleles['aux'] = alleles['aux'].str.replace(' ','').str.replace(',',' ')
alleles['ID2'] = alleles['Gene Symbol'] + '_' + alleles['aux'] # ID2 will serve as unique "allele ID" for each allele (Gene symbol + corrected allele name)

# Flatten a list containing all values in ID2 column
IDsalleles = list(alleles['ID2'])
IDsflat = list()
for i,j in zip(IDsalleles,samples):
    IDsflat.append([i]*len(j.split(',')))
flatIDs =  [item for sublist in IDsflat for item in sublist]
# Flatten a list containing all carrier samples for all alleles
flatsamples = [item for sublist in samples for item in sublist.split(',')]
# Flatten a list containing all genotype carriers for all alleles
flatgenot = [item for sublist in genot for item in sublist.split(';')]

cols = ['allele','samples','genotypes']
# Create a dataframe called "flatalleles". Each row contains one hit: one allele found in a single sample. So, samples with multiple alleles in multiple genes will have multiple rows associated
flatalleles = pd.DataFrame(dict(zip(cols,[flatIDs,flatsamples,flatgenot])))
flatalleles['samples'] = flatalleles['samples'].str.rstrip('_gt')
flatalleles['gender'] = flatalleles['samples'].map(dict(zip(list(df['sample']),list(df['gender']))))
flatalleles = flatalleles.loc[~flatalleles['genotypes'].str.contains('0/0')].copy()
# To ease analysis, convert genotypes to numbers (number of alleles): 0/1--> 1,1/1 --> 2, alleles with variants that must be phased, assume: 0/1,0/1 or 0/1,1/1 or 1/1,0/1 --> 1 allele, 1/1,1/1 --> 2 alleles
flatalleles['convert_genotypes'] = flatalleles['genotypes'].apply(lambda x: ','.join(list(set(x.split(',')))).replace('1/1,0/1','1').replace('0/1,1/1','1').replace('0/1','1').replace('1/1','2'))

#Useful info to assign phenotypes in G6PD later --> This search gives 0 results since all males will be 1/1 and thus they will get a 2: flatalleles.loc[(flatalleles['allele'].str.contains('G6PD')) & (flatalleles['convert_genotypes'] == '1') & (flatalleles['gender'] == 'H')]

df['alleles'] = '' #Initializa a columns called "alleles"
df['sample'] = df['sample'].astype(str)
d = dict()

# removekey is a function that helps to delete redundant alleles according to the criteria belowself.
# When a condition is fulfilled and a redundant allele must be elimintared, removekey is invoked
def removekey(d, key):
    r = dict(d)
    del r[key]
    return r

d_countalleles = dict()
# This loop contains all specific cases which needed curation in our data. It removes or corrects those alleles which are found redundant
# As a general rule, when two redundant alleles are present, the one with higher number of variants is kept.
for s in list(df['sample']): # This loops interrogates all possible alleles in each sample and outputs a curated dictionary with the correct alleles
    l =  list(flatalleles['allele'].loc[flatalleles['samples'] == s].values)
    alleles_aux = list(flatalleles['allele'].loc[flatalleles['samples'] == s].values)
    genot_aux = list(flatalleles['convert_genotypes'].loc[flatalleles['samples'] == s].values)
    d_aux = dict(zip(alleles_aux,genot_aux))

    for i in d_aux.keys():
        if d_aux[i] == '1':
            d_aux[i] = i.replace('_','_*1/')
        elif d_aux[i] == '2':
            d_aux[i] = i + '/' + i.split('_')[1]

    tenta_alleles = ','.join(list(d_aux.values()))
    if ('SLCO1B1_*1/*15' in tenta_alleles) & ('SLCO1B1_*1/*5' in tenta_alleles):
        d_aux = removekey(d_aux, 'SLCO1B1_*5')
    if ('SLCO1B1_*15/*15' in tenta_alleles) & ('SLCO1B1_*5/*5' in tenta_alleles):
        d_aux = removekey(d_aux, 'SLCO1B1_*5')
    if ('SLCO1B1_*1/*15' in tenta_alleles) & ('SLCO1B1_*5/*5' in tenta_alleles):
        d_aux = removekey(d_aux, 'SLCO1B1_*5')
        d_aux = removekey(d_aux, 'SLCO1B1_*15')
        d_aux['SLCO1B1_*5'] = 'SLCO1B1_*5/*15'

    if ('CYP2B6_*1/*34' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*4')
        d_aux = removekey(d_aux, 'CYP2B6_*9')
        d_aux = removekey(d_aux, 'CYP2B6_*6')
        d_aux = removekey(d_aux, 'CYP2B6_*7')
        d_aux = removekey(d_aux, 'CYP2B6_*36')
        if ('CYP2B6_*1/*13' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*8')
        tenta_alleles = ','.join(list(d_aux.values()))
    else:
        if ('CYP2B6_*1/*7' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*4')
            d_aux = removekey(d_aux, 'CYP2B6_*9')
            d_aux = removekey(d_aux, 'CYP2B6_*6')
            if ('CYP2B6_*1/*13' in tenta_alleles):
                d_aux = removekey(d_aux, 'CYP2B6_*8')
            tenta_alleles = ','.join(list(d_aux.values()))
        elif ('CYP2B6_*1/*36' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*4')
            d_aux = removekey(d_aux, 'CYP2B6_*9')
            d_aux = removekey(d_aux, 'CYP2B6_*6')
            d_aux = removekey(d_aux, 'CYP2B6_*22')
            if ('CYP2B6_*1/*13' in tenta_alleles):
                d_aux = removekey(d_aux, 'CYP2B6_*8')
            tenta_alleles = ','.join(list(d_aux.values()))
        elif ('CYP2B6_*1/*8' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*8')
            tenta_alleles = ','.join(list(d_aux.values()))
    if ('CYP2B6_*1/*4' in tenta_alleles) & ('CYP2B6_*1/*6' in tenta_alleles) & ('CYP2B6_*1/*9' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*4')
        d_aux = removekey(d_aux, 'CYP2B6_*9')
        if ('CYP2B6_*1/*13' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*6')
        tenta_alleles = ','.join(list(d_aux.values()))

    if ('CYP2B6_*4/*4' in tenta_alleles) & ('CYP2B6_*6/*6' in tenta_alleles) & ('CYP2B6_*9/*9' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*4')
        d_aux = removekey(d_aux, 'CYP2B6_*9')
        tenta_alleles = ','.join(list(d_aux.values()))

    if ('CYP2B6_*4/*4' in tenta_alleles) & ('CYP2B6_*1/*6' in tenta_alleles) & ('CYP2B6_*1/*9' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*4')
        d_aux = removekey(d_aux, 'CYP2B6_*9')
        d_aux['CYP2B6_*6'] = 'CYP2B6_*4/*6'
        tenta_alleles = ','.join(list(d_aux.values()))

    if ('CYP2B6_*1/*4' in tenta_alleles) & ('CYP2B6_*1/*6' in tenta_alleles) & ('CYP2B6_*9/*9' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*4')
        d_aux = removekey(d_aux, 'CYP2B6_*9')
        d_aux['CYP2B6_*6'] = 'CYP2B6_*9/*6'
        if ('CYP2B6_*1/*13' in tenta_alleles):
            d_aux = removekey(d_aux, 'CYP2B6_*6')
            d_aux['CYP2B6_*9'] = 'CYP2B6_*1/*9'
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('CYP2B6_*1/*16' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*18')
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('CYP2B6_*1/*13' in tenta_alleles)  & ('CYP2B6_*6/*6' in tenta_alleles):
        d_aux['CYP2B6_*6'] = 'CYP2B6_*1/*6'
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('CYP2B6_*1/*26' in tenta_alleles)  & ('CYP2B6_*6/*6' in tenta_alleles):
        d_aux['CYP2B6_*6'] = 'CYP2B6_*1/*6'
    if ('CYP2B6_*1/*20' in tenta_alleles)  & ('CYP2B6_*1/*16' in tenta_alleles)& ('CYP2B6_*1/*6' in tenta_alleles):
        d_aux = removekey(d_aux, 'CYP2B6_*16')
        d_aux = removekey(d_aux, 'CYP2B6_*20')
        d_aux['CYP2B6_*18'] = 'CYP2B6_*1/*18'
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('TPMT_*1/*3A' in tenta_alleles) & ('TPMT_*1/*3B' in tenta_alleles) & ('TPMT_*1/*3C' in tenta_alleles):
        d_aux = removekey(d_aux, 'TPMT_*3B')
        d_aux = removekey(d_aux, 'TPMT_*3C')
    if ('TPMT_*1/*3A' in tenta_alleles) & ('TPMT_*1/*3B' in tenta_alleles) & ('TPMT_*3C/*3C' in tenta_alleles):
        d_aux = removekey(d_aux, 'TPMT_*3B')
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('TPMT_*3A/*3A' in tenta_alleles) & ('TPMT_*3B/*3B' in tenta_alleles) & ('TPMT_*3C/*3C' in tenta_alleles):
        d_aux = removekey(d_aux, 'TPMT_*3B')
        d_aux = removekey(d_aux, 'TPMT_*3C')
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('G6PD_*1/Asahi' in tenta_alleles) & ('G6PD_*1/A-202A-376G' in tenta_alleles):
        d_aux = removekey(d_aux, 'G6PD_Asahi')
        tenta_alleles = ','.join(list(d_aux.values()))
    if ('G6PD_Asahi/Asahi' in tenta_alleles) & ('G6PD_A-202A-376G/A-202A-376G' in tenta_alleles):
        d_aux = removekey(d_aux, 'G6PD_Asahi')
        tenta_alleles = ','.join(list(d_aux.values()))

    d[s] = ','.join(list(d_aux.values()))
    d_countalleles[s] = len(list(d_aux.values()))

# Map resulting alleles onto the final dataframe
df['SNV_alleles'] = df['sample'].map(d)
df['SNV_N_alleles'] = df['sample'].map(d_countalleles)

# Create a column for each specific gene. It will be empty if a sample is not carrier and filled with the PGx allele otherwise
GENES = list(set(list(alleles['Gene Symbol'])))
for gene in GENES:
    df[gene] = df['SNV_alleles'].apply(lambda x: ','.join([j for j in x.split(',') if gene in j]))
# Up to this point, only alleles with SNPs have been considered. In the next steps, alleles with indel variants (that have been manually curated) are included
df.loc[df['SNV_N_alleles'] == 0, ['SNV_alleles']] = 'NAN'
df.to_csv('onlySNVS_haplotypes.csv',sep='\t',index = None)


# In this second part, we included indel variation which was manually analysed in parallel to avoid losing positive cases
# The aim is to include the resulting actionable diplotypes from indel variation
# INDELS:

indels = pd.read_csv('ActionableIndels_ALLGENES.csv',sep='\t') # This .csv file contains manually curated alleles with indel variants
df = pd.read_csv('onlySNVS_haplotypes.csv',sep='\t')
df['sample'] = df['sample'].astype(str)
# Translate internal IDs to annonymous ones
sampledict = pd.read_csv('sample_dictionary_20210105.csv',sep='\t', header = None)# Sampledict is a table with internal to annonimous ids translation: restricted
sampledict = sampledict.rename(columns={0:'sample',1:'ORIGINAL'}).copy()
sampledict['sample'] = sampledict['sample'].astype(str)
d = dict(zip(list(sampledict['ORIGINAL']),list(sampledict['sample'])))
def annonymize(d, l):
    m = ','.join([d[i] for i in l])
    return m
indels['samples'] = indels['samples'].apply(lambda x: annonymize(d, x.split(';')))
indels['zigosity'] = indels['zigosity'].apply(lambda x: x.replace('Heteroz','0/1').replace('Homoz','1/1'))

#Create a copy of the dataframe df output above as "onlySNVS_haplotypes...csv" with specific columns
df = df[['sample','from','from_general','gender','panel','SNV_alleles','SNV_N_alleles']].copy()

#Read the Ref_table with all PGx alleles and get alleles containing indels
#alleles = pd.read_csv('/home/jlanillos/CNIO/PGx/scripts/scripts_backup_20210916/Ref_table.csv',sep='\t')
alleles = pd.read_csv('/mnt/64716603-5b56-4f9a-b195-c11560647a3a/Projects/PHARMACOGENETICS/PGx_project/0_PGx_manuscript/npjGenomicMedicine/Response_to_reviewers/SuppTables/Ref_table.csv',sep='\t')
alleles = alleles.loc[(alleles['SNV_only'] == 'INDEL') & (alleles['Actionable allele'] == 'Yes')]

genot = list(indels['zigosity'])
samples =  list(indels['samples'])
indels['ID2'] = indels['SYMBOL'] + '_' + indels['Allele']
IDsalleles = list(indels['ID2'])
IDsflat = list()
for i,j in zip(IDsalleles,samples):
    IDsflat.append([i]*len(j.split(',')))
flatIDs =  [item for sublist in IDsflat for item in sublist]
flatsamples = [item for sublist in samples for item in sublist.split(',')]
flatgenot = [item for sublist in genot for item in sublist.split(';')]
cols = ['allele','samples','genotypes']
flatalleles = pd.DataFrame(dict(zip(cols,[flatIDs,flatsamples,flatgenot])))
flatalleles['convert_genotypes'] = flatalleles['genotypes'].apply(lambda x: ','.join(list(set(x.split(',')))).replace('1/1,0/1','1').replace('0/1,1/1','1').replace('0/1','1').replace('1/1','2'))

df['alleles'] = ''
df['sample'] = df['sample'].astype(str)
d = dict()
def removekey(d, key):
    r = dict(d)
    del r[key]
    return r
d_countalleles = dict()
for s in list(df['sample']):
    l =  list(flatalleles['allele'].loc[flatalleles['samples'] == s].values)
    alleles_aux = list(flatalleles['allele'].loc[flatalleles['samples'] == s].values)
    genot_aux = list(flatalleles['convert_genotypes'].loc[flatalleles['samples'] == s].values)
    d_aux = dict(zip(alleles_aux,genot_aux))

    for i in d_aux.keys():
        if d_aux[i] == '1':
            d_aux[i] = i.replace('_','_*1/')
        elif d_aux[i] == '2':
            d_aux[i] = i + '/' + i.split('_')[1]
    tenta_alleles = ','.join(list(d_aux.values()))
#    if ('NUDT15_*1/*3' in tenta_alleles) & ('NUDT15_*1/*2' in tenta_alleles):
#        d_aux = removekey(d_aux, 'NUDT15_*1/*3')

    d[s] = ','.join(list(d_aux.values()))
    d_countalleles[s] = len(list(d_aux.values()))
df['INDELS_alleles'] = df['sample'].map(d)
df['INDELS_N_alleles'] = df['sample'].map(d_countalleles)
df.loc[df['INDELS_N_alleles'] == 0, ['INDELS_alleles']] = 'NAN'


# Merge alleles coming from SNVs plus alleles with indels
df['SNV_alleles'] = df['SNV_alleles'].astype(str)
df['INDELS_alleles'] = df['INDELS_alleles'].astype(str)
def mergebutnotNANs(SNValleles, INDELalleles):
    SNValleles = SNValleles.split(',')
    INDELalleles = INDELalleles.split(',')
    ALLalleles = SNValleles + INDELalleles
    ALLalleles = [x for x in ALLalleles if x != 'NAN']
    ALLalleles = ','.join(ALLalleles)
    return ALLalleles
df['alleles'] = df.apply(lambda x: mergebutnotNANs(x['SNV_alleles'], x['INDELS_alleles']), axis = 1)


# Arrange redundancy in alleles with SNVs and indelsself.
 #NUDT15 gene:
#if NUDT15_*3 and NUDT15_*2 in a sample, then remove NUDT15*2
#if NUDT15_*3/*3 and NUDT15_*2/*2 in a sample, then remove NUDT15*2*2
def redundantAllelesNUDT15(alleles):
    alleles = alleles.split(',')
    if ('NUDT15_*1/*3' in alleles) and ('NUDT15_*1/*2' in alleles):
        alleles.remove('NUDT15_*1/*3')
    elif ('NUDT15_*3/*3' in alleles) and ('NUDT15_*2/*2' in alleles):
        alleles.remove('NUDT15_*3/*3')
    elif ('NUDT15_*3/*3' in alleles) and ('NUDT15_*1/*2' in alleles):
        alleles.remove('NUDT15_*3/*3')
        alleles.remove('NUDT15_*1/*2')
        alleles.append('NUDT15_*2/*3')
    return ','.join(alleles)

df['alleles'] = df['alleles'].apply(lambda x: redundantAllelesNUDT15(x))

def countAlleles(alleles):
    if alleles == '':
        return 0
    else:
        return len(alleles.split(','))

df['N_alleles'] = df['alleles'].apply(lambda x: countAlleles(x))

# Repeat again: Create a column for each specific gene. It will be empty if a sample is not carrier and filled with the PGx allele otherwise
alleles = pd.read_csv('Alleles.csv',sep='\t')
alleles = alleles.loc[(alleles['count_carrier_ids'].astype(str) != 'nan') & (alleles['Actionable allele'] == 'Yes')].copy()
GENES = list(set(list(alleles['Gene Symbol'])))
for gene in GENES:
    df[gene] = df['alleles'].apply(lambda x: ','.join([j for j in x.split(',') if gene in j]))

# Save the final output:
df.to_csv('haplotypes.csv',sep='\t',index = None)
